;Name: TOTP WristApp
;Version: TOTP
;Description: TOTP WristApp - by Roberto Abdelkader Martinez Perez
;This is a TOTP generator wristapp for the Timex Datalink, providing secure
;two-factor authentication by generating time-based one-time passwords
;compatible with TOTP-enabled services.
;
;TIP:  Download your watch faster:  Download a WristApp once, then do not send it again.  It stays in the watch!
INCLUDE         "WRISTAPP.I"
;
; (1) Program specific constants
;
FLAGBYTE        EQU     $61
;   Bit 0 indicates that we want to show the segments instead of the message
;
START           EQU     *
;
; (2) System entry point vectors
L0110:          jmp     MAIN    ; The main entry point - WRIST_MAIN
L0113:          rts             ; Called when we are suspended for any reason - WRIST_SUSPEND
                nop
                nop
L0116:          rts             ; Called to handle any timers or time events - WRIST_DOTIC
                nop
                nop
L0119:          rts             ; Called when the COMM app starts and we have timers pending - WRIST_INCOMM
                nop
                nop
L011c:          rts             ; Called when the COMM app loads new data - WRIST_NEWDATA
                nop
                nop

L011f:          lda     STATETAB,X ; The state table get routine - WRIST_GETSTATE
                rts

L0123:          jmp     HANDLE_STATE0
                db      STATETAB-STATETAB
;
; (3) Program strings
S6_TOTP:        timex6  " TOTP "
;
; <autogenerated>
; THIS SECTION IS AUTO-GENERATED *** DO NOT MODIFY ***
;
CURRENT_YEAR    EQU     23

UT0             EQU     $70
UT1             EQU     $F2
UT2             EQU     $91
UT3             EQU     $65

UNIXTIME:
                db      UT0
                db      UT1
                db      UT2
                db      UT3

TEMP:
                db      0
                db      0
                db      0
                db      0
;
; </autogenerated>
;

;
; (4) State Table
; (4) State Table
STATETAB:
                db      0
                db      EVT_ENTER,TIM_ONCE,0    ; Initial state
                db      EVT_RESUME,TIM_ONCE,0   ; Resume from a nested app
                db      EVT_DNNEXT,TIM_ONCE,0   ; Next button
                db      EVT_DNPREV,TIM_ONCE,0   ; Prev button
                db      EVT_MODE,TIM_ONCE,$FF   ; Mode button
                db      EVT_END
;
; (5) State Table 0 Handler
; This is called to process the state events.  We only see ENTER, RESUME, and DNNEXT events
;
HANDLE_STATE0:
                bset    1,$8f                   ; Indicate that we can be suspended
                lda     BTNSTATE                ; Get the event
                cmp     #EVT_DNNEXT             ; Did they press the next button?
                beq     DOTOGGLE                ; Yes, toggle what we are displaying
                cmp     #EVT_DNPREV
                beq     RESETUT
CLEARIT         bclr    0,FLAGBYTE              ; Start us in the show display state
SHOWDISP        jsr     CLEARALL                ; Clear the display
                lda     #S6_TOTP-START          ; Get the offset for the second string
                jsr     PUT6MID                 ; and put it on the middle line
                lda     #SYS8_MODE              ; Get the system offset for the 'MODE' string
                jmp     PUTMSGBOT               ; and put it on the bottom line

SHOWLEAP        brclr   0,FLAGBYTE,SHOWDISP ; Do we want to see the main display?
                jsr     CLEARALL                ; Clear the display

MAYBETHISYEAR   jsr     GET_YEAR                ; Get the current year
                sub     #CURRENT_YEAR
                beq     ISTHISYEAR
                lda     #$80
                sta     TEMP
                lda     #$33
                sta     TEMP+1
                lda     #$e1
                sta     TEMP+2
                lda     #$1
                sta     TEMP+3
                bsr     ADDSECS
                bsr     DEBUGUNIX
                rts

                ; tax
                ; jmp     PUT_YEARX               ; Put the current year in the year place

ISTHISYEAR      jmp     SAYEOLMSG

DOTOGGLE        brset   0,FLAGBYTE,CLEARIT      ; If it is set, just jump to clear it like normal
                bset    0,FLAGBYTE              ; Already clear, so set it
                bra     SHOWLEAP                ; and let the refresh code handle it

RESETUT         lda     #UT0                    ; First reset the unix ts
                sta     UNIXTIME
                lda     #UT1
                sta     UNIXTIME+1
                lda     #UT2
                sta     UNIXTIME+2
                lda     #UT3
                sta     UNIXTIME+3
                bra     DOTOGGLE

ADDSECS         lda     UNIXTIME
                add     TEMP
                sta     UNIXTIME
                lda     UNIXTIME+1
                adc     TEMP+1
                sta     UNIXTIME+1
                lda     UNIXTIME+2
                adc     TEMP+2
                sta     UNIXTIME+2
                lda     UNIXTIME+3
                adc     TEMP+3
                sta     UNIXTIME+3
                rts

DEBUGUNIX
                lda     UNIXTIME
                bsr     GETBYTE
                jsr     PUTTOP12

                lda     UNIXTIME+1
                bsr     GETBYTE
                jsr     PUTTOP34

                lda     UNIXTIME+2
                bsr     GETBYTE
                jsr     PUTTOP56

                lda     UNIXTIME+3
                bsr     GETBYTE
                jsr     PUTMID12

                rts

GETBYTE
                sta     DATDIGIT2               ; And save it away
                lsra                            ; Extract the high nibble
                lsra
                lsra
                lsra

                sta     DATDIGIT1               ; And save it
                lda     DATDIGIT2               ; Get the byte again
                and     #$0f                    ; Extract the low nibble
                sta     DATDIGIT2               ; And save it
                rts

                ; ldx     UNIXTIME+1


                ;; TODO: Use this at the end of the list
                ; jmp     SAYEOLMSG


                ; lda     #24
                ; sta     PARM_YEAR               ; We are interested in the year 2024
                ; lda     #2
                ; sta     PARM_MONTH              ; and the month of February
                ; jsr     GET_MONTHLEN            ; Get the number of days in the month
                ; tax
                ; jsr     PUT_MINUTEX             ; Put the number of days in the month in the minutes place

                ; ldx     #69
                ; jsr     GETBCDHI
                ; tax
                ; lda     POSL1_1
                ; jsr     PUTLINE1

                ; ldx     #69
                ; jsr     GETBCDLOW
                ; tax
                ; lda     POSL1_2
                ; jsr     PUTLINE1

                ; jsr     GET_YEAR                ; Get the current year
                ; tax
                ; jsr     PUT_YEARX               ; Put the current year in the year place
                ; jmp     CLEARSYM



;
; (6) Our only real piece of working code...
;
; (7) This is the main initialization routine which is called when we first get the app into memory
;
MAIN:
                lda     #$c0                      ; We want button beeps and to indicate that we have been loaded
                sta     $96
                clr     FLAGBYTE        ; start with a clean slate
                rts
