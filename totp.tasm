;Name: TOTP WristApp
;Version: TOTP
;Description: TOTP WristApp - by Roberto Abdelkader Martinez Perez
;This is a TOTP generator wristapp for the Timex Datalink, providing secure
;two-factor authentication by generating time-based one-time passwords
;compatible with TOTP-enabled services.
;
;TIP:  Download your watch faster:  Download a WristApp once, then do not send it again.  It stays in the watch!
INCLUDE         "WRISTAPP.I"
;
; (1) Program specific constants
;
FLAGBYTE        EQU     $61
;   Bit 0 indicates that we want to show the segments instead of the message
;
START           EQU     *
;
; (2) System entry point vectors
L0110:          jmp     MAIN    ; The main entry point - WRIST_MAIN
L0113:          rts             ; Called when we are suspended for any reason - WRIST_SUSPEND
                nop
                nop
L0116:          rts             ; Called to handle any timers or time events - WRIST_DOTIC
                nop
                nop
L0119:          rts             ; Called when the COMM app starts and we have timers pending - WRIST_INCOMM
                nop
                nop
L011c:          rts             ; Called when the COMM app loads new data - WRIST_NEWDATA
                nop
                nop

L011f:          lda     STATETAB,X ; The state table get routine - WRIST_GETSTATE
                rts

L0123:          jmp     HANDLE_STATE0
                db      STATETAB-STATETAB
;
; (3) Program strings
S6_TOTP:        timex6  " TOTP "

;
; <autogenerated>
; THIS SECTION IS AUTO-GENERATED *** DO NOT MODIFY ***
;
%TCOUNT%
;
; </autogenerated>
;

;
; (4) State Table
; (4) State Table
STATETAB:
                db      0
                db      EVT_ENTER,TIM_ONCE,0    ; Initial state
                db      EVT_RESUME,TIM_ONCE,0   ; Resume from a nested app
                db      EVT_DNNEXT,TIM_ONCE,0   ; Next button
                db      EVT_DNPREV,TIM_ONCE,0   ; Prev button
                db      EVT_MODE,TIM_ONCE,$FF   ; Mode button
                db      EVT_END
;
; (5) State Table 0 Handler
; This is called to process the state events.  We only see ENTER, RESUME, and DNNEXT events
;
HANDLE_STATE0:
                bset    1,$8f                   ; Indicate that we can be suspended
                lda     BTNSTATE                ; Get the event
                cmp     #EVT_DNNEXT             ; Did they press the next button?
                beq     DOTOGGLE                ; Yes, toggle what we are displaying
CLEARIT         bclr    0,FLAGBYTE              ; Start us in the show display state
SHOWDISP        jsr     CLEARALL                ; Clear the display
                lda     #S6_TOTP-START          ; Get the offset for the second string
                jsr     PUT6MID                 ; and put it on the middle line
                lda     #SYS8_MODE              ; Get the system offset for the 'MODE' string
                jmp     PUTMSGBOT               ; and put it on the bottom line

SHOWLEAP        brclr   0,FLAGBYTE,SHOWDISP     ; Do we want to see the main display?
                jsr     CLEARALL                ; Clear the display
                bsr     INCCOUNTER
                bsr     DEBUGUNIX
                rts

DOTOGGLE        brset   0,FLAGBYTE,CLEARIT      ; If it is set, just jump to clear it like normal
                bset    0,FLAGBYTE              ; Already clear, so set it
                bra     SHOWLEAP                ; and let the refresh code handle it

GETBYTE
                sta     DATDIGIT2               ; And save it away
                lsra                            ; Extract the high nibble
                lsra
                lsra
                lsra

                sta     DATDIGIT1               ; And save it
                lda     DATDIGIT2               ; Get the byte again
                and     #$0f                    ; Extract the low nibble
                sta     DATDIGIT2               ; And save it
                rts

INCCOUNTER      lda     TCOUNT
                add     #1
                sta     TCOUNT
                lda     TCOUNT+1
                adc     #0
                sta     TCOUNT+1
                lda     TCOUNT+2
                adc     #0
                sta     TCOUNT+2
                lda     TCOUNT+3
                adc     #0
                sta     TCOUNT+3
                rts

DEBUGUNIX
                lda     TCOUNT+3
                bsr     GETBYTE
                jsr     PUTTOP12

                lda     TCOUNT+2
                bsr     GETBYTE
                jsr     PUTTOP34

                lda     TCOUNT+1
                bsr     GETBYTE
                jsr     PUTTOP56

                lda     TCOUNT
                bsr     GETBYTE
                jsr     PUTMID12

                rts

;
; (6) Our only real piece of working code...
;
; (7) This is the main initialization routine which is called when we first get the app into memory
;
MAIN:
                lda     #$c0                      ; We want button beeps and to indicate that we have been loaded
                sta     $96
                clr     FLAGBYTE        ; start with a clean slate
                rts
