;Name: TOTP WristApp
;Version: TOTP
;Description: TOTP WristApp - by Roberto Abdelkader Martinez Perez
;This is a TOTP generator wristapp for the Timex Datalink, providing secure
;two-factor authentication by generating time-based one-time passwords
;compatible with TOTP-enabled services.
;
;TIP:  Download your watch faster:  Download a WristApp once, then do not send it again.  It stays in the watch!
INCLUDE         "WRISTAPP.I"

;
; Memory Segments Utilization for TOTP Calculator SHA1 Calculations
; -----------------------------------------------------------------
; The memory segments listed below are leveraged during the SHA1 hash
; calculations for the TOTP calculator. These segments are temporarily
; repurposed to accommodate variables specific to the TOTP calculation process,
; alongside their original intended usage.
;
; Segment $043a-$0462 (40 bytes)
;   - Original Usage:
;       - BUF_PHONENUM (12 bytes): Initially reserved for phone number storage.
;       - EXTRACTBUF (28 bytes): Allocated for data extraction. Documentation
;           discrepancies note it as 32 or 31 bytes. However, practical use
;           determines it effectively as 31 bytes since clearing the 32nd byte
;           also clears the first alarm hours field.
;   - TOTP Variables:
;       - V_A to V_F (6 variables * 4 bytes each): Variables used in
;           intermediate steps of SHA1 calculations.
;       - V_K (4 bytes): Additional variable for SHA1 computation.
;       - V_TEMP (4 bytes): Temporary storage during calculations.
;
;     Note: Of the allocated 40 bytes, 32 are used for TOTP variables (V_A-V_F,
;     V_K, V_TEMP) during SHA1 calculations. The original variables
;     (BUF_PHONENUM, EXTRACTBUF) are key for EEPROM data recovery outside these
;     computations.
;
; Segment $04d2 (32 bytes)
;   - Original Usage:
;       - MSGBUF (32 bytes): Reserved for message buffering.
;         Note: No adverse effects observed when clearing up to 40 bytes,
;         suggesting some flexibility in the original design.
;   - TOTP Variables:
;       - H_0 to H_4 (5 variables * 4 bytes each): Variables for storing
;           intermediate hash values.
;       - H2_0 to H2_4 (5 variables * 4 bytes each): Additional variables for
;           hash computations, used in the HMAC-SHA1 algorithm.
;     Note: Exactly 40 bytes are used for these TOTP variables, fully utilizing
;     the segment during the SHA1 hash calculation phase.
;
; This repurposing of memory segments allows for efficient use of available
; resources for TOTP SHA1 hash calculations without interfering with the
; original intended uses of these memory areas.
;

V_A                 EQU     $043a
V_B                 EQU     $043e
V_C                 EQU     $0442
V_D                 EQU     $0446
V_E                 EQU     $044a
V_F                 EQU     $044e
V_K                 EQU     $0452
V_TEMP              EQU     $0456

H_0                 EQU     $04d2
H_1                 EQU     $04d6
H_2                 EQU     $04da
H_3                 EQU     $04de
H_4                 EQU     $04e2
H2_0                EQU     $04e6
H2_1                EQU     $04ea
H2_2                EQU     $04ee
H2_3                EQU     $04f2
H2_4                EQU     $04f6

;
; (1) Program specific constants
;
; SECS_DIG1       EQU     $63
; SECS_DIG2       EQU     $64
FLAGBYTE        EQU     $61
COUNTDOWN       EQU     $63
V_I             EQU     $64

RAM_ADDR        EQU     $2B
RAM_SIZE        EQU     $24

;   Bit 0 indicates that we want to show the segments instead of the message
;
START           EQU     *
;
; (2) System entry point vectors
L0110:          jmp     MAIN       ; The main entry point - WRIST_MAIN
L0113:          rts                ; Called when we are suspended for any reason - WRIST_SUSPEND
                nop
                nop
L0116:          jmp     SECTIC     ; Called to handle any timers or time events - WRIST_DOTIC
L0119:          rts                ; Called when the COMM app starts and we have timers pending - WRIST_INCOMM
                nop
                nop
L011c:          rts                ; Called when the COMM app loads new data - WRIST_NEWDATA
                nop
                nop

L011f:          lda     STATETAB0,X ; The state table get routine - WRIST_GETSTATE
                rts

L0123:          jmp     HANDLE_STATE0
                db      STATETAB0-STATETAB0
; L0127:          jmp     HANDLE_STATE1
;                 db      STATETAB1-STATETAB0
;
; (3) Program strings
S6_SECS:         timex6  "   SEC"
S6_TOTP:         timex6  " TOTP "
S8_GITHUB:       timex   " GITHUB "

;
; <autogenerated>
; THIS SECTION IS AUTO-GENERATED *** DO NOT MODIFY ***
;
%TCOUNT%
;
; </autogenerated>
;


;
; (4) State Table
STATETAB0:
                db      0
                db      EVT_ENTER,TIM_ONCE,0   ; Initial state
                db      EVT_TIMER2,TIM2_8TIC,0
                db      EVT_RESUME,TIM_ONCE,0   ; Resume from a nested app
                db      EVT_DNNEXT,TIM2_8TIC,0   ; Next button
                db      EVT_DNPREV,TIM_ONCE,0   ; Prev button
                db      EVT_DNSET,TIM_ONCE,0   ; Set button
                db      EVT_MODE,TIM_ONCE,$FF   ; Mode button
                db      EVT_END

; STATETAB1:
;                 db      1
;                 db      EVT_MODE,TIM_ONCE,$FF     ; Mode button
;                 db      EVT_END

;
; (5) State Table 0 Handler
; This is called to process the state events.  We only see ENTER, RESUME, and DNNEXT events
;
HANDLE_STATE0:
                bset    1,APP_FLAGS             ; Indicate that we can be suspended
                lda     BTNSTATE                ; Get the event
                cmp     #EVT_DNNEXT
                beq     FIRSTSHOWCD
                cmp     #EVT_TIMER2
                beq     SHOWCOUNTDOWN
                cmp     #EVT_DNPREV
                beq     SHOWNOENTRIES
                cmp     #EVT_DNSET
                beq     DELETEENTRY
                ; fall into SHOWBANNER
CLEARIT         jsr     CLEARALL                ; Clear the display
SHOWBANNER      lda     #S6_TOTP-START          ; Get the offset for the second string
                jsr     PUT6MID                 ; and put it on the middle line
                lda     #SYS8_MODE              ; Get the system offset for the 'MODE' string
                jmp     PUTMSGBOT               ; and put it on the bottom line
FIRSTSHOWCD     jsr     CLEARALL                ; Clear the display
SHOWCOUNTDOWN
                lda     #S8_GITHUB-START
                jsr     BANNER8
SHOWCODE        lda     #S6_SECS-START
                jsr     PUT6MID
                ldx     COUNTDOWN
                cpx     #10                     ; If the countdown is <= 10 seconds
                bls     BLINK_SECS              ; Blink the seconds position
                jsr     FMTXLEAD0                 ; Otherwise just print the number
                jsr     PUTMID12
                rts
BLINK_SECS      ldx     #COUNTDOWN
                lda     #BLINK_MID12
                jsr     START_BLINKP
                bset    2,BTNFLAGS              ; Mark a blink routine as pending
                rts

SHOWNOENTRIES   lda     #SYS6_NO
                jsr     PUTMSG1
                lda     #S6_TOTP-START
                jsr     PUT6MID
                lda     #SYS8_ENTRIES
                jmp     PUTMSGBOT

DELETEENTRY     jmp     SAYHOLDTODELETE
; GETBYTE
;                 sta     DATDIGIT2               ; And save it away
;                 lsra                            ; Extract the high nibble
;                 lsra
;                 lsra
;                 lsra

;                 sta     DATDIGIT1               ; And save it
;                 lda     DATDIGIT2               ; Get the byte again
;                 and     #$0f                    ; Extract the low nibble
;                 sta     DATDIGIT2               ; And save it
;                 rts


; DEBUGUNIX
;                 lda     TCOUNT
;                 bsr     GETBYTE
;                 jsr     PUTTOP12

;                 lda     TCOUNT+1
;                 bsr     GETBYTE
;                 jsr     PUTTOP34

;                 lda     TCOUNT+2
;                 bsr     GETBYTE
;                 jsr     PUTTOP56

;                 lda     TCOUNT+3
;                 bsr     GETBYTE
;                 jsr     PUTMID12

;                 rts

BINOP:                                          ; Self modifying code to do a binary operation
BINOP_ITER      EQU     *+1
                ldx     #4                      ; Set the default iterator. 4 bytes for 32 bit operations
BINOP_SRC       EQU     *+1
BINOP_REPEAT    lda     $4000,X
BINOP_OP        EQU     *
                nop
                nop
                nop
BINOP_DST       EQU     *+1
                sta     $4000,X
                decx
                bne     BINOP_ITER
                ldx     #4
                sta     BINOP_ITER              ; Reset the default iterator
                rts
OVERWRITINGBINOP:
                sta     BINOP_OP                ; Set the operation
                lda     BINOP_DST               ; Set the second operand to the first byte of the destination
                sta     BINOP_OP+1
                lda     BINOP_DST+1             ; Set the second operand to the second byte of the destination
                sta     BINOP_OP+2
                bra     BINOP                   ; Do the operation
ADD32:                                          ; Uses BINOP to add two 32 bit numbers
                clc                             ; Clear the carry bit
                lda     #$E9                    ; E9 = ADC Indexed 8-bit offset
                bra     OVERWRITINGBINOP

OR32:                                           ; Uses BINOP to OR two 32 bit numbers
                lda     #$EA                    ; EA = OR Indexed 8-bit offset
                bra     OVERWRITINGBINOP
XOR32:                                          ; Uses BINOP to XOR two 32 bit numbers
                lda     #$E8                    ; E8 = EOR Indexed 8-bit offset
                bra     OVERWRITINGBINOP
AND32:                                          ; Uses BINOP to AND two 32 bit numbers
                lda     #$E4                    ; E4 = AND Indexed 8-bit offset
                bra     OVERWRITINGBINOP
SET32:                                          ; Uses BINOP to set a 32 bit number
                lda     #$9D                    ; 9D = nop
                sta     BINOP_OP                ; Set the operation
                sta     BINOP_OP+1
                sta     BINOP_OP+2
                bra     BINOP                   ; Do the operation

INIT_SHA1:
                lda     #SHA1_INIT_H0-START
                sta     BINOP_SRC
                lda     #H_0-START
                sta     BINOP_DST
                lda     #20
                sta     BINOP_ITER
                bra     SET32

SHA1_PROCESS_BLOCK:
                lda     #H_0-START
                sta     BINOP_SRC
                lda     #V_A-START
                sta     BINOP_DST
                lda     #20
                sta     BINOP_ITER
                bra     SET32

                clra
                sta     V_I
BLOCK_LOOP      cmp     #20
                blo     LESS_THAN_20
                cmp     #40
                blo     LESS_THAN_40
                cmp     #60
                blo     LESS_THAN_60
                ; The last block >= 60 & < 80
                ; TODO
LESS_THAN_20    bra     END_BLOCK_IF        ; TODO
LESS_THAN_40    bra     END_BLOCK_IF        ; TODO
LESS_THAN_60    bra     END_BLOCK_IF        ; TODO
FIRST_ROUND     bra     END_ROUND           ; TODO
END_BLOCK_IF    lda     V_I
                cmp     #16
                blo     FIRST_ROUND
                ; Rest of the rounds
                ; TODO
                bra     END_ROUND
END_ROUND       nop                         ; TODO: Do the assignements
                lda     V_I                 ; Are we done?
                cmp     #80
                blo     BLOCK_LOOP
                rts


;
; This callback gets called every second
;
RESETCOUNTDOWN
                clr     BTNFLAGS                  ; Stop blinking
                lda     #30
                sta     COUNTDOWN
                sec                               ; Set the carry flag
                ldx     #4                        ; And add it to the time
INCCOUNT        decx
                lda     TCOUNT,X
                adc     #0
                sta     TCOUNT,X
                bne     INCCOUNT
                lda     FLAGBYTE                    ; Change the demo code
                eor     #1
                sta     FLAGBYTE
                rts
SECTIC:
                lda     COUNTDOWN
                deca
                beq     RESETCOUNTDOWN
                sta     COUNTDOWN
                rts

; HANDLE_STATE1:
;                 bset        1,APP_FLAGS                 ; Indicate that we can be suspended
;                 bra         SHOWCOUNTDOWN

;
; (6) Our only real piece of working code...
;
; (7) This is the main initialization routine which is called when we first get the app into memory
;
MAIN:
                lda     #$c1            ; App is loaded, uses system rules for button beeps and second timer
                sta     WRISTAPP_FLAGS
                lda     #30
                sta     COUNTDOWN
                ; ldx     #RAM_SIZE       ; Upper ram is 201 bytes
                ; clra
; CLEAN_RAM       sta     RAM_ADDR,X
                ; decx
                ; bne     CLEAN_RAM
                clr     FLAGBYTE
                rts


; vim: set expandtab ts=4 sw=4 filetype=asm:
