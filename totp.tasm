;Name: TOTP WristApp
;Version: TOTP
;Description: TOTP WristApp - by Roberto Abdelkader Martinez Perez
;This is a TOTP generator wristapp for the Timex Datalink, providing secure
;two-factor authentication by generating time-based one-time passwords
;compatible with TOTP-enabled services.
;
;TIP:  Download your watch faster:  Download a WristApp once, then do not send it again.  It stays in the watch!
INCLUDE         "WRISTAPP.I"

;
; Memory Segments Utilization for TOTP Calculator SHA1 Calculations
; -----------------------------------------------------------------
; The memory segments listed below are leveraged during the SHA1 hash
; calculations for the TOTP calculator. These segments are temporarily
; repurposed to accommodate variables specific to the TOTP calculation process,
; alongside their original intended usage.
;
; Segment $043a-$0462 (40 bytes)
;   - Original Usage:
;       - BUF_PHONENUM (12 bytes): Initially reserved for phone number storage.
;       - EXTRACTBUF (28 bytes): Allocated for data extraction. Documentation
;           discrepancies note it as 32 or 31 bytes. However, practical use
;           determines it effectively as 31 bytes since clearing the 32nd byte
;           also clears the first alarm hours field.
;   - TOTP Variables:
;       - V_A to V_F (6 variables * 4 bytes each): Variables used in
;           intermediate steps of SHA1 calculations.
;       - V_K (4 bytes): Additional variable for SHA1 computation.
;       - V_TEMP (4 bytes): Temporary storage during calculations.
;       - V_TEMP2 (4 bytes): Additional temporary storage during calculations.
;
;     Note: Of the allocated 40 bytes, 36 are used for TOTP variables (V_A-V_F,
;     V_K, V_TEMP, V_TEMP2) during SHA1 calculations. The original variables
;     (BUF_PHONENUM, EXTRACTBUF) are key for EEPROM data recovery outside these
;     computations.
;
; Segment $04d2 (32 bytes)
;   - Original Usage:
;       - MSGBUF (32 bytes): Reserved for message buffering.
;         Note: No adverse effects observed when clearing up to 40 bytes,
;         suggesting some flexibility in the original design.
;   - TOTP Variables:
;       - H_0 to H_4 (5 variables * 4 bytes each): Variables for storing
;           intermediate hash values.
;       - H2_0 to H2_4 (5 variables * 4 bytes each): Additional variables for
;           hash computations, used in the HMAC-SHA1 algorithm.
;     Note: Exactly 40 bytes are used for these TOTP variables, fully utilizing
;     the segment during the SHA1 hash calculation phase.
;
; This repurposing of memory segments allows for efficient use of available
; resources for TOTP SHA1 hash calculations without interfering with the
; original intended uses of these memory areas.
;

V_A                 EQU     $043a
V_B                 EQU     $043e
V_C                 EQU     $0442
V_D                 EQU     $0446
V_E                 EQU     $044a
V_F                 EQU     $044e
V_K                 EQU     $0452
V_TEMP              EQU     $0456

H_0                 EQU     $04d2
H_1                 EQU     $04d6
H_2                 EQU     $04da
H_3                 EQU     $04de
H_4                 EQU     $04e2
H2_0                EQU     $04e6
H2_1                EQU     $04ea
H2_2                EQU     $04ee
H2_3                EQU     $04f2
H2_4                EQU     $04f6

;
; (1) Program specific constants
;
OFFSET          EQU     $60
COUNTDOWN       EQU     $61

;   Bit 0 indicates that we want to show the segments instead of the message
;
START           EQU     *
;
; (2) System entry point vectors
L0110:          jmp     MAIN       ; The main entry point - WRIST_MAIN
L0113:          rts                ; Called when we are suspended for any reason - WRIST_SUSPEND
                nop
                nop
L0116:          jmp     SECTIC     ; Called to handle any timers or time events - WRIST_DOTIC
L0119:          rts                ; Called when the COMM app starts and we have timers pending - WRIST_INCOMM
                nop
                nop
L011c:          rts                ; Called when the COMM app loads new data - WRIST_NEWDATA
                nop
                nop

L011f:          lda     STATETAB0,X ; The state table get routine - WRIST_GETSTATE
                rts

L0123:          jmp     HANDLE_STATE0
                db      STATETAB0-STATETAB0

;
; (3) Program strings
;
S6_SECS:         timex6  "   SEC"
S6_TOTP:         timex6  " TOTP "
S8_GITHUB:       timex   " GITHUB "


;
; These addresses in conjunction with the OFFSET variable are used to
; calculate the absolute address to be used in different parts of the self
; modifying code.
;
LOADBYTE_ADDRHI     EQU     (LOADBYTE & $FF00) / 0x0100
LOADBYTE_ADDRLO     EQU     (LOADBYTE & $00FF)

OP_RHS_ADDRHI       EQU     (OP_RHS & $FF00) / 0x0100
OP_RHS_ADDRLO       EQU     (OP_RHS & $00FF)
OP_DST_ADDRHI       EQU     (OP_DST & $FF00) / 0x0100
OP_DST_ADDRLO       EQU     (OP_DST & $00FF)

ADD_LHS_ADDRHI      EQU     (ADD_LHS & $FF00) / 0x0100
ADD_LHS_ADDRLO      EQU     (ADD_LHS & $00FF)

ONE                 db      $aa,$aa,$00,$ff

; BUFFER:             db      $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00

;
; <autogenerated>
; THIS SECTION IS AUTO-GENERATED *** DO NOT MODIFY ***
;

; TCOUNT is a 4 byte counter that is incremented every 30 seconds
; it is used as the counter for the TOTP algorithm.
%TCOUNT%

;
; </autogenerated>
;


;
; (4) State Table
STATETAB0:
                db      0
                db      EVT_ENTER,TIM_ONCE,0   ; Initial state
                db      EVT_RESUME,TIM_ONCE,0   ; Resume from a nested app
                db      EVT_DNNEXT,TIM2_8TIC,0   ; Next button
                db      EVT_MODE,TIM_ONCE,$FF   ; Mode button
                db      EVT_END


;
; (5) State Table 0 Handler
; This is called to process the state events.  We only see ENTER, RESUME, and DNNEXT events
;
HANDLE_STATE0:
                bset    1,APP_FLAGS             ; Indicate that we can be suspended
                lda     BTNSTATE                ; Get the event
                cmp     #EVT_DNNEXT
                beq     TESTSTUFF
                ; fall into SHOWBANNER
CLEARIT         jsr     CLEARALL                ; Clear the display
SHOWBANNER      lda     #S6_TOTP-START          ; Get the offset for the second string
                jsr     PUT6MID                 ; and put it on the middle line
                lda     #SYS8_MODE              ; Get the system offset for the 'MODE' string
                jmp     PUTMSGBOT               ; and put it on the bottom line

; FIRSTSHOWCD     jsr     CLEARALL                ; Clear the display
; SHOWCOUNTDOWN
;                 lda     #S8_GITHUB-START
;                 jsr     BANNER8
; SHOWCODE        lda     #S6_SECS-START
;                 jsr     PUT6MID
;                 ldx     COUNTDOWN
;                 cpx     #10                     ; If the countdown is <= 10 seconds
;                 bls     BLINK_SECS              ; Blink the seconds position
;                 jsr     FMTXLEAD0                 ; Otherwise just print the number
;                 jsr     PUTMID12
;                 rts
; BLINK_SECS      ldx     #COUNTDOWN
;                 lda     #BLINK_MID12
;                 jsr     START_BLINKP
;                 bset    2,BTNFLAGS              ; Mark a blink routine as pending
;                 rts

; SHOWNOENTRIES   lda     #SYS6_NO
;                 jsr     PUTMSG1
;                 lda     #S6_TOTP-START
;                 jsr     PUT6MID
;                 lda     #SYS8_ENTRIES
;                 jmp     PUTMSGBOT

; DELETEENTRY     jmp     SAYHOLDTODELETE

TESTSTUFF       lda     #(TCOUNT & 0xff00) / 0x0100
                sta     OP_RHS
                sta     OP_DST
                lda     #(TCOUNT & 0x00ff)
                sta     OP_RHS+1
                sta     OP_DST+1
                lda     #(ONE & 0xff00) / 0x0100
                sta     XOR_LHS
                ; sta     OP_RHS
                lda     #(ONE & 0x00ff)
                sta     XOR_LHS+1
                ; sta     OP_RHS+1
                ; lda     #$69
                ; sta     SET_VALUE
                bsr     XOROP
                bra     DEBUGUNIX

FIRSTBYTE:      lda     #LOADBYTE_ADDRLO
                sub     OFFSET
                sta     LOADBYTE+1
                lda     #LOADBYTE_ADDRHI
                sbc     #0
                sta     LOADBYTE
                clr     OFFSET
NEXTBYTE:       ldx     OFFSET
LOADBYTE        EQU     *+1
                lda     $4000,X
                inc     OFFSET
GETBYTE:
                sta     DATDIGIT2               ; And save it away
                lsra                            ; Extract the high nibble
                lsra
                lsra
                lsra

                sta     DATDIGIT1               ; And save it
                lda     DATDIGIT2               ; Get the byte again
                and     #$0f                    ; Extract the low nibble
                sta     DATDIGIT2               ; And save it
                rts

DEBUGUNIX:      jsr     CLEARALL                ; Clear the display
                lda     #LOADBYTE-TCOUNT
                sta     OFFSET

                bsr     FIRSTBYTE
                jsr     PUTTOP12

                bsr     NEXTBYTE
                jsr     PUTTOP34

                bsr     NEXTBYTE
                jsr     PUTTOP56

                bsr     NEXTBYTE
                jmp     PUTMID12

ADDOP:
                lda     #(ADD_CB-OP_CB)-1
                sta     OP_CB
                clc
                bra     OPERATION

SUBOP:
                lda     #(SUB_CB-OP_CB)-1
                sta     OP_CB
                clc
                bra     OPERATION

COPYOP:
                lda     #(OP_SAVE-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

ANDOP:
                lda     #(AND_CB-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

NOTOP:
                lda     #(NOT_CB-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

OROP:
                lda     #(OR_CB-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

SETOP:
                lda     #(SET_CB-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

XOROP:
                lda     #(XOR_CB-OP_CB)-1
                sta     OP_CB
                bra     OPERATION

ROLOP:
                lda     OP_IDX
                deca
                sta     ROLOP_IDX
                lda     OP_DST
                sta     ROLOP_EOR
                sta     ROLOP_STA
                lda     OP_DST+1
                sta     ROLOP_EOR+1
                sta     ROLOP_STA+1
                lda     #(ROL_CB-OP_CB)-1
                sta     OP_CB
                clc
                bsr     OPERATION
                bcc     ROLOP_END
                ; fall into ROLOP_SET1
ROLOP_SET1      lda     #1
ROLOP_IDX       EQU     *+1
                ldx     #3
ROLOP_EOR       EQU     *+1
                eor     $4000,X
ROLOP_STA       EQU     *+1
                sta     $4000,X
ROLOP_END:      rts

OPERATION:
OP_IDX          EQU     *+1
                ldx     #4
OP_REPEAT:      decx
OP_RHS          EQU     *+1
                lda     $4000,X
OP_CB           EQU     *+1
                bsr     OP_SAVE
OP_DST          EQU     *+1
OP_SAVE:        sta     $4000,X
                tstx
                bne     OP_REPEAT
                rts

ADD_LHS         EQU     *+1
ADD_CB:         adc     $4000,X
                rts

SUB_LHS         EQU     *+1
SUB_CB:         sbc     $4000,X
                rts

AND_LHS         EQU     *+1
AND_CB:         and     $4000,X
                rts

FF_ADDR         db      $ff
NOT_CB:         eor     FF_ADDR
                rts

OR_LHS          EQU     *+1
OR_CB:          ora     $4000,X
                rts

ROL_CB:         rola
                rts

SET_VALUE       EQU     *+1
SET_CB:         lda     #$69
                rts

XOR_LHS         EQU     *+1
XOR_CB:         eor     $4000,X
                rts

; XOR32:
;                 ldx     #4
; XOR32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 eor     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     XOR32_REPEAT
;                 rts

; SET32:
;                 ldx     #4
; SET32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 lda     #$69
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     SET32_REPEAT
;                 rts

; ROL32:
;                 clc
;                 ldx     #4
; ROL32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 rola
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     ROL32_REPEAT
;                 bcs     ROL32_SET1
;                 rts
; ROL32_SET1:     lda     #1
;                 eor     DST_ADDR+3
;                 sta     DST_ADDR+3
;                 rts

; OR32:
;                 ldx     #4
; OR32_REPEAT:    decx
;                 lda     RHS_ADDR,X
;                 ora     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     OR32_REPEAT
;                 rts

; NOT32:
;                 ldx     #4
; NOT32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 eor     FF_ADDR
;                 bra     CONT_NOT32
; FF_ADDR         db      $ff
; CONT_NOT32:     sta     DST_ADDR,X
;                 tstx
;                 bne     NOT32_REPEAT
;                 rts

; AND32:
;                 ldx     #4
; AND32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 and     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     AND32_REPEAT
;                 rts

; COPY32:
;                 ldx     #4
; COPY32_REPEAT:  decx
;                 lda     RHS_ADDR,X
;                 lda     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     COPY32_REPEAT
;                 rts

; DEC32:
;                 clc
;                 ldx     #4
; DEC32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 sbc     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     DEC32_REPEAT
;                 rts

; ADD32:
;                 clc
;                 ldx     #4
; ADD32_REPEAT:   decx
;                 lda     RHS_ADDR,X
;                 adc     LHS_ADDR,X
;                 sta     DST_ADDR,X
;                 tstx
;                 bne     ADD32_REPEAT
;                 rts

; BINOP:                                          ; Self modifying code to do a binary operation
; BINOP_ITER      EQU     *+1
;                 ldx     #4                      ; Set the default iterator. 4 bytes for 32 bit operations
; BINOP_RHS       EQU     *+1
; BINOP_REPEAT:   lda     $4000,X
; BINOP_OP        EQU     *+1
;                 bra     BINOP_DST-1             ; Self modifying code for the operation callback
; BINOP_DST       EQU     *+1
;                 sta     $4000,X
;                 decx
;                 bne     BINOP_REPEAT
;                 ldx     #4
;                 sta     BINOP_ITER              ; Reset the default iterator
;                 rts

RESETCOUNTDOWN
                clr     BTNFLAGS                  ; Stop blinking
                lda     #30
                sta     COUNTDOWN
                sec                               ; Set the carry flag
                ldx     #4                        ; And add it to the time
INCCOUNT        decx
                lda     TCOUNT,X
                adc     #0
                sta     TCOUNT,X
                bne     INCCOUNT
                rts
;
; This callback gets called every second to keep TCOUNT up to date.
;   - The COUNTDOWN variable is decremented
;   - If the COUNTDOWN variable is zero, the countdown is reset to 30 seconds
;     and TCOUNT is incremented by one.
;
SECTIC:
                lda     COUNTDOWN
                deca
                beq     RESETCOUNTDOWN              ; If we are at zero, reset the countdown
                sta     COUNTDOWN
                rts

;
; (6) Our only real piece of working code...
;
; (7) This is the main initialization routine which is called when we first get the app into memory
;
MAIN:
                lda     #$c1            ; App is loaded, uses system rules for button beeps and second timer
                sta     WRISTAPP_FLAGS
                lda     #30
                sta     COUNTDOWN
                rts

; vim: set expandtab ts=4 sw=4 filetype=asm:
